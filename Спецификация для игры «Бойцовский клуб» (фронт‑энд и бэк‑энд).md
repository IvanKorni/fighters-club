## 1. Общее описание игры

В игре участвуют два игрока. После регистрации/авторизации пользователь попадает на главный экран, где отображаются его данные и кнопка «Бой». Нажатие на кнопку помещает пользователя в очередь. Алгоритм матчмейкинга ищет партнёра; по условиям бизнеса ожидание длится 30 секунд, после чего проверяется, появился ли второй игрок. Если совпадение найдено, создаётся бой. В бою каждый ход состоит из выбора зоны атаки и защиты (голова, тело или ноги) и нажатия кнопки «Сделать ход». У каждого хода есть таймер в 30 секунд; если один игрок нажал кнопку, а второй не успел, учитывается только ход успевшего. У каждого игрока есть шкала здоровья; проигрывает тот, у кого здоровье падает до нуля.

Игра должна обеспечивать честное сопоставление игроков, хранить состояние боя на сервере, защищать персональные данные игроков (никнейм, email, пароль) и работать как на настольных, так и на мобильных устройствах.

## 2. Функциональные требования

### 2.1 Регистрация и авторизация

- **Регистрация**. Пользователь должен ввести:
    
    1. Адрес электронной почты (используется как логин).
        
    2. Пароль. По руководству Google/Web.Dev рекомендуется разрешать браузерам предлагать сильные пароли и не ограничивать пользователей правилами, которые блокируют сгенерированные пароли[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Ensure%20users%20enter%20secure%20passwords).
        
    3. Никнейм (уникальное отображаемое имя в игре).
        
- Пароли не хранятся в открытом виде. Для аутентификации используется Keycloak как Identity Provider, который обеспечивает безопасное хранение паролей с использованием современных алгоритмов (PBKDF2, bcrypt, Argon2) и автоматически применяет уникальную соль для каждого пароля[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#Use_a_cryptographically_strong_credential-specific_salt#:~:text=Salting%C2%B6). Соль делает невозможным использование радужных таблиц и сравнение одинаковых паролей разных пользователей[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#Use_a_cryptographically_strong_credential-specific_salt#:~:text=A%20salt%20is%20a%20unique%2C,to%20the%20number%20of%20hashes). Такой подход соответствует современным best practices и позволяет использовать проверенные решения вместо собственной реализации.
    
- Не разрешать компрометированные пароли. После ввода пароля его нужно проверить через сервис Have I Been Pwned или аналогичный API[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Don%27t%20allow%20compromised%20passwords).
    
- Разрешить вставку пароля (не блокировать copy/paste) и не заставлять пользователей менять пароли без причины[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Allow%20password%20pasting).
    
- В случае ошибок регистрации (занятый email, слабый пароль, ошибки формата) выводить понятные сообщения с указанием, как исправить проблему[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=If%20you%20do%20reject%20the,a%20response%20from%20your%20server).
    
- **Авторизация**. Пользователь вводит email и пароль. После проверки пароля по хешу на сервере сервер выдаёт токен (JWT или session token). Сессия действует до выхода или истечения срока действия. В случае неправильного ввода выводится уведомление.
    
- Поддержать сброс пароля (ссылка на email).
    
- Поддержать многофакторную аутентификацию (можно в будущем), но по умолчанию она необязательна[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Offer%20multi).
    

### 2.2 Главный экран

- После входа отображаются:
    
    - Никнейм пользователя.
        
    - Текущий уровень/рейтинг (если решено внедрять рейтинги).
        
    - Шкала здоровья (по умолчанию 100 HP). На этом экране она отображает здоровье после завершённого боя. Для нового боя здоровье сбрасывается до 100.
        
    - Кнопка **«Бой»**. Одновременно должна быть возможность отменить участие в очереди (кнопка «Отменить ожидание»).
        
    - Кнопка выхода из аккаунта.
        

### 2.3 Очередь и матчмейкинг

- При нажатии на «Бой» клиент отправляет запрос `/v1/queue/join` на сервер. Сервер добавляет игрока в очередь.
    
- На экране ожидания отображается таймер обратного отсчёта на 30 секунд и текст «Поиск соперника…». В любой момент пользователь может отменить ожидание.
    
- Если в течение 30 секунд находится другой игрок, сервер создаёт матч и уведомляет клиентов через WebSocket или Server‑Sent Events (см. раздел «Сетевое взаимодействие»). Оба игрока перенаправляются на экран боя.
    
- Если второй игрок не найден за 30 секунд, пользователь остаётся в очереди, пока соперник не появится. Таймер обнуляется или продолжает отсчёт для следующей проверки; UI может показывать «Ожидание соперника…» без таймера.
    

### 2.4 Бой

- **Экраны**. Бой отображается в виде двух персонажей с полосами здоровья. В центре — элементы управления:
    
    - Блок выбора **атаки** — три радиокнопки «Голова», «Тело», «Ноги».
        
    - Блок выбора **защиты** — те же три варианты.
        
    - Кнопка **«Сделать ход»**, активная только если выбраны оба варианта.
        
    - Таймер хода (30 секунд), показывающий оставшееся время до конца хода.
        
    - Таблица или список, отображающий историю ходов (номер хода, выбранные зоны, нанесённый урон).
        
- **Логика хода**. Каждый ход длится 30 секунд.
    
    - Если оба игрока нажали «Сделать ход», сервер одновременно обрабатывает выборы.
        
    - Если только один игрок сделал ход до истечения 30 секунд, учитывается только его атака; защита второго считается неопределённой (все зоны уязвимы).
        
    - По истечении 30 секунд сервер автоматически обрабатывает имеющиеся выборы. Клиентам отправляется событие с результатом и начинается следующий ход.
        
- **Расчёт урона**. В каждый ход атакующий игрок выбирает зону, а защищающий — одну из трёх зон. Пример бизнес‑правил (можно скорректировать):
    
    - Базовый урон для попадания в голову — 20 HP, тело — 15 HP, ноги — 10 HP.
        
    - Если защита совпадает с атакой, урон уменьшается на 50 %.
        
    - При промахе (атакующий не выбрал ход в 30 секунд) урон не наносится.
        
    - Урон всегда вычитается из здоровья соперника.
        
- **Конец боя**. Бой завершается, когда здоровье одного игрока ≤ 0. Сервер отправляет финальное событие обоим клиентам с результатом (победа/поражение). Игрок возвращается на главный экран, где здоровье восстанавливается и статистика обновляется.
    

### 2.5 Журнал и статистика

- Сервер должен хранить историю матчей с указанием игроков, продолжительности, количества ходов, выбранных атак и защит, победителя.
    
- Пользователь может просмотреть список своих последних боёв и общий счёт побед/поражений.
    

## 3. Спецификация фронт‑энда

### 3.1 Общие требования

- Использовать современный веб‑фреймворк (React, Vue, Angular) или мобильный фреймворк (Flutter) для реализации SPA.
    
- Реализовать адаптивную верстку под экраны смартфонов и планшетов. Воспользоваться медиазапросами и процентными размерами.
    
- Интерфейс должен быть локализован (русский/английский) и поддерживать лёгкое добавление новых языков.
    
- Соблюдать доступность: обеспечить навигацию с клавиатуры, контрастность, альтернативный текст для изображений.
    
- Все сетевые запросы должны выполняться через HTTPS.
    
- Для реального времени использовать WebSocket. При потере соединения клиент должен попытаться переподключиться и уведомить пользователя.
    

### 3.2 Компоненты и состояния

|Экран/компонент|Основные элементы|Сетевые вызовы|
|---|---|---|
|**Форма регистрации**|Поля email (`type=email`, `autocomplete="email"`), пароль (`type=password`, `autocomplete="new-password"`), никнейм; индикатор сложности пароля; чекбокс согласия с правилами.|POST `/api/auth/register` (передаётся email, пароль, nickname). После успешной регистрации — переход на экран входа/авторизация.|
|**Форма входа**|Поля email (`autocomplete="email"`), пароль (`autocomplete="current-password"`); ссылка «Забыли пароль?».|POST `/api/auth/login` (возвращает токен). Токен хранится в `localStorage` или `httpOnly` cookie; состояние авторизации в контексте приложения.|
|**Главный экран**|Полоса здоровья, счётчик побед/поражений, кнопка «Бой», кнопка выхода.|GET `/v1/persons/{id}` для загрузки персональных данных; GET `/v1/stats` для загрузки статистики; POST `/v1/queue/join` при нажатии на «Бой»; POST `/v1/queue/leave` при отмене.|
|**Экран ожидания**|Отображение таймера 30 секунд, индикатора подключения к WebSocket и кнопки «Отменить ожидание».|WebSocket подключение на `/ws/queue` (получение события `match_found`), POST `/v1/queue/leave` при отмене.|
|**Экран боя**|Две шкалы здоровья (в процентах); элементы выбора атаки и защиты (радиокнопки); таймер хода; кнопка «Сделать ход»; журнал ходов; кнопка «Сдаться» (по желанию).|WebSocket `/ws/game/{matchId}` для получения/отправки событий (`turn_start`, `move_result`, `game_end`); POST `/v1/game/move` отправляет атаку и защиту.|
|**Экран статистики**|Список матчей (дата, соперник, результат); фильтр по периоду.|GET `/v1/matches?userId={id}&from={date}&to={date}&page={page}&size={size}`.|

### 3.3 Обработка ошибок и таймаутов

- Клиент должен отображать уведомления (toast) при сетевых ошибках (недоступен сервер, истек токен и т.п.).
    
- Если истекает токен авторизации, клиент перенаправляется на экран входа.
    
- На экране боя при отсутствии ответа сервера более 5 секунд должна отображаться анимация загрузки. Если соединение WebSocket разорвалось, клиент пытается переподключиться в течение 10 секунд; если не удаётся, бой считается прерванным.
    

### 3.4 Тестирование

- Реализовать unit‑тесты для компонентов (Jest, Vue Test Utils).
    
- Провести интеграционные тесты взаимодействия с API (playwright/puppeteer).
    
- Тестировать на актуальных версиях браузеров (Chrome, Firefox, Safari, Edge) и мобильных устройств.
    

## 4. Спецификация бэк‑энда

### 4.1 Архитектура и технологии

- **Язык/фреймворк**: Node.js (Express или NestJS), Python (Django/Flask), Go или любой язык, поддерживающий WebSocket и асинхронность.
    
- **База данных**: реляционная (PostgreSQL) или документная (MongoDB). Таблицы/коллекции: `users`, `matches`, `moves`, `queue`.
    
- **WebSocket‑сервер**: используется для реального времени (матчмейкинг, ход, результаты).
    
- **Аутентификация**: JWT (JSON Web Token) или сессии. Token передаётся в заголовках, защищается HTTPS.
    
- **Хранение паролей**:
    
    - Используется Keycloak как Identity Provider для управления аутентификацией. Keycloak обеспечивает безопасное хранение паролей с использованием современных алгоритмов (PBKDF2, bcrypt, Argon2) и автоматически применяет уникальную соль для каждого пароля[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#Use_a_cryptographically_strong_credential-specific_salt#:~:text=Salting%C2%B6).
        
    - Keycloak настраивает work factor для баланса между скоростью и сложностью хеширования[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#Use_a_cryptographically_strong_credential-specific_salt#:~:text=The%20work%20factor%20is%20the,to%20crack%20the%20password%20hash).
        
    - Пароли проверяются на наличие в базе утечек (Have I Been Pwned) на уровне Auth Service при регистрации[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Don%27t%20allow%20compromised%20passwords).
        

### 4.2 Модель данных

- **User**:
    
    - `id: UUID` (первичный ключ).
        
    - `email: string` (уникально).
        
    - `nickname: string` (уникально).
        
    - `keycloakUserId: string` (опционально, для связи с Keycloak).
        
    - `createdAt`, `updatedAt`.
        
    - **Примечание**: Пароли и токены хранятся в Keycloak, а не в базе данных сервиса. Это обеспечивает централизованное управление аутентификацией и соответствует принципам разделения ответственности.
        
- **Match**:
    
    - `id: UUID`.
        
    - `player1Id`, `player2Id` (ссылки на пользователей).
        
    - `status: enum` — `waiting`, `in_progress`, `finished`.
        
    - `player1HP`, `player2HP` (int, стартовое значение 100).
        
    - `currentTurnStart: datetime` (время начала текущего хода).
        
    - `moves: array` — список ходов (ссылки на таблицу `moves`).
        
    - `createdAt`, `finishedAt`.
        
- **Move**:
    
    - `id: UUID`.
        
    - `matchId` (foreign key).
        
    - `playerId`.
        
    - `turnNumber: int`.
        
    - `attackTarget: enum(head, body, legs)`.
        
    - `defenseTarget: enum(head, body, legs)`.
        
    - `timestamp` (когда отправлен).
        
- **Queue**:
    
    - В простейшем случае очередь хранится в памяти сервера (list of user IDs). При масштабировании можно использовать Redis (sorted set по времени входа).
        

### 4.3 REST / WebSocket API

|Метод / путь|Описание запроса|Тело запроса|Ответ|
|---|---|---|---|
|`POST /v1/auth/registration`|Регистрация.|`{email, password, nickname}`|201 Created. `{userId, token}` либо ошибка.|
|`POST /v1/auth/login`|Вход в систему.|`{email, password}`|200 OK. `{token}` или ошибка.|
|`POST /v1/queue/join`|Поместить пользователя в очередь.|Заголовок Authorization с токеном.|200 OK. `{message: "waiting"}`. Уведомление о найденном матче происходит через WebSocket.|
|`POST /v1/queue/leave`|Выход из очереди.|—|200 OK.|
|`GET /v1/persons/{id}`|Получить персональные данные пользователя.|—|200 OK. `{id, email, nickname}`.|
|`GET /v1/stats`|Получить статистику пользователя.|Параметры: `userId` (опционально, по умолчанию текущий пользователь)|200 OK. `{wins, losses, rating, ...}`.|
|`GET /v1/matches`|Получить список матчей пользователя.|Параметры: `userId` (опционально), `from`, `to`, `page`, `size`|200 OK. Список матчей с пагинацией.|
|`POST /v1/game/move`|Отправить ход.|`{matchId, attackTarget, defenseTarget, turnNumber}`|202 Accepted. Обработка хода происходит сервером; результат отправляется через WebSocket.|

**Примечание:** Все API используют версионирование через префикс `/v1/`. Profile Service разделен на два сервиса: `person-service` (`/v1/persons`) для персональных данных и `stats-service` (`/v1/stats`, `/v1/matches`) для статистики и истории матчей.

#### WebSocket события

- `/ws/queue` — канал для уведомления о найденном матче.
    
    - Сервер отправляет `{type: "match_found", matchId, opponentNickname}`.
        
- `/ws/game/{matchId}` — канал боя.
    
    - `turn_start` — содержит номер хода и время окончания (timestamp).
        
    - `turn_update` — приходит после приёма хода одного игрока (для информирования второго).
        
    - `turn_result` — результат расчёта урона; содержит HP обоих игроков, выбранные атаки/защиты, нанесённый урон.
        
    - `game_end` — сообщение о завершении боя (победа/поражение).
        

### 4.4 Логика матчмейкинга и боя

1. **Вход в очередь**: при получении запроса `/v1/queue/join` сервер добавляет пользователя в очередь. Если очередь содержит другого пользователя, создаётся запись `Match` со статусом `in_progress`, игроки удаляются из очереди, генерируется уникальный идентификатор матча. Каждому игроку отправляется событие `match_found` через WebSocket.
    
2. **Начало боя**: после подтверждения подключения обоих игроков сервер устанавливает `player1HP = player2HP = 100`, `currentTurnStart = now()`, `turnNumber = 1` и отправляет `turn_start` со временем окончания (`now() + 30 секунд`).
    
3. **Приём хода**: сервер принимает ходы с помощью REST (`/v1/game/move`) или по WebSocket. Для каждого хода сохраняется выбор атаки и защиты, помечается время получения.
    
4. **Тайм‑аут хода**: по истечении 30 секунд от `currentTurnStart` сервер проверяет, сделали ли игроки ход. Если нет, ход пропускается (урон не наносится) для пропустивших игроков.
    
5. **Расчёт урона**: сервер сравнивает атаку игрока с защитой соперника и определяет урон согласно правилам (описаны в § 2.4). Результат обновляет `player1HP`/`player2HP` в таблице `Match`.
    
6. **Проверка окончания**: если `player1HP <= 0` или `player2HP <= 0`, сервер завершает матч (`status = finished`, `finishedAt = now()`) и отправляет событие `game_end` обоим игрокам.
    
7. **Переход к следующему ходу**: если матч не завершён, сервер увеличивает `turnNumber` и `currentTurnStart`, отправляет событие `turn_result`, затем `turn_start` с новым таймером.
    
8. **Обработка отключения**: если игрок отключается, сервер может (вариант на выбор) считать его проигравшим, либо автоматически завершить матч вничью. Решение зависит от бизнес‑требований.
    

### 4.5 Безопасность и защита

- Шифровать весь трафик по HTTPS/WSS.
    
- Хранить токены в безопасных `httpOnly` cookie или использовать CSRF‑token.
    
- Реализовать лимиты на частоту запросов (`rate limiting`) для предотвращения brute‑force и DoS.
    
- Проверять введённые пользователями данные (email, пароль, никнейм) на корректность и защищать API от SQL‑injection и XSS.
    
- Хранить логи входа и подозрительных активностей, чтобы оповещать пользователей и администраторов.
    
- Соблюдать требования GDPR: предоставить возможность удалить аккаунт и все связанные данные.
    

### 4.6 Масштабирование и отказоустойчивость

- Использовать балансировщик нагрузки для распределения игроков между экземплярами сервера.
    
- Очередь матчмейкинга должна располагаться в общей памяти (Redis), чтобы все экземпляры сервера имели доступ к общей очереди.
    
- Состояние матчей хранить в БД и в памяти сервера; можно использовать in‑memory хранилище с периодической синхронизацией.
    
- Для WebSocket при масштабировании потребуется прокси (например, Nginx) и sticky‑sessions или использование сервисов типа Socket.io + Redis‑Adapter.
    

## 5. Нефункциональные требования

- **Производительность**: время ответа API — не более 200 мс для большинства запросов; передача данных WebSocket — менее 100 мс задержки.
    
- **Надёжность**: сервис должен выдерживать одновременную игру до нескольких тысяч пользователей.
    
- **Безопасность**: выполняется рекомендации OWASP (солёные хеши, защита от утечек паролей, проверка сложных паролей)[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Don%27t%20allow%20compromised%20passwords)[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#Use_a_cryptographically_strong_credential-specific_salt#:~:text=Salting%C2%B6).
    
- **Логирование**: записывать важные события (регистрация, вход, выход, начало боя, ошибки).
    
- **Поддерживаемость**: код должен быть покрыт тестами; документирован API (OpenAPI/Swagger).
    
- **Масштабируемость**: архитектура должна легко масштабироваться горизонтально.