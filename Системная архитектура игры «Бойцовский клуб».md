## Общее описание и бизнес‑логика

Игра представляет собой PvP‑файтинг, в котором сражаются два игрока. После регистрации или авторизации пользователь попадает на главный экран, где может вступить в очередь. Матчмейкер подбирает соперника (в течение 30 секунд), после чего начинается бой. Каждый ход длится 30 секунд: игроки выбирают зоны атаки и защиты (голова/тело/ноги) и нажимают «Сделать ход». При истечении таймера выполняются действия успевших игроков. Урон зависит от зоны (пример: голова — 20 HP, тело — 15 HP, ноги — 10 HP). Бой заканчивается, когда здоровье одного из игроков падает до 0. Сервер хранит историю матчей, статистику и обеспечивает честный подбор соперников.

Эта спецификация доработана с точки зрения системного архитектора, выбран стек — фронт‑энд на **React** и бэк‑энд на **Java (Spring Boot)**. Предлагаемая архитектура учитывает требования из исходной спецификации, а также современные производственные практики: разделение на сервисы по доменным областям, высокую доступность, безопасность, масштабирование и тестирование.

## Архитектура в целом

**Компоненты:**

1. **Клиент (React SPA)**
    
    - Реализован с использованием React 18 и TypeScript. Состояние приложения управляется через Redux Toolkit или React Context. Для сетевых запросов используется Axios и WebSocket API. Приложение адаптивно (используются CSS‑media queries) и доступно для экранных читалок (ARIA‑атрибуты, навигация с клавиатуры).
        
    - Локализация осуществляется с помощью библиотеки `react-i18next`; поддерживаются русский и английский языки, добавление языков не требует переработки кода.
        
2. **API Gateway (Spring Cloud Gateway или Nginx) - опционально**
    
    - Единственная точка входа для клиентов. Маршрутизирует REST‑запросы к соответствующим сервисам, обеспечивает кросс‑срезные функции — аутентификация/авторизация, ограничение скорости (rate limiting), сбор логов и мониторинг. Применение паттерна API Gateway уменьшает связность между клиентом и микросервисами и позволяет объединять ответы от нескольких сервисов[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=2).
        
    - В текущей реализации сервисы доступны напрямую по разным портам. Gateway может быть добавлен для production-развертывания.
        
    - В случае мобильных клиентов может быть реализован специализированный BFF (backend‑for‑frontend).
        
3. **Сервисы бэк‑энда (Java 17+, Spring Boot 3)**
    
    Каждый сервис разворачивается как отдельный Spring Boot‑приложение и имеет собственную базу данных (паттерн _database per service_)[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=3). Сервисы взаимодействуют через REST и события (Kafka/RabbitMQ). Таким образом достигается слабая связанность и возможность независимого масштабирования.
    
    - **Auth Service** — отвечает за регистрацию, вход и управление сессиями. Использует **Keycloak** как Identity Provider для аутентификации и авторизации. Keycloak обеспечивает безопасное хранение паролей (использует PBKDF2, bcrypt или Argon2 в зависимости от конфигурации), генерацию и валидацию JWT токенов (access/refresh), управление пользователями и ролями, поддержку OAuth2/OIDC стандартов. Сервис может проверять пароли через API Have I Been Pwned при регистрации и не позволяет использовать скомпрометированные пароли[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=third). Токены — JWT, хранятся в HttpOnly‑cookie или в хранилище на стороне клиента. Поддерживается сброс пароля по электронной почте и многофакторная аутентификация через Keycloak как опциональная функция.
        
    - **Profile Service** — разделен на два сервиса:
        - **Person Service** (`person-service`) — хранит персональные данные пользователей (email, nickname). Предоставляет CRUD операции через `/v1/persons`. По требованию GDPR предоставляет удаление аккаунтов.
        - **Stats Service** (`stats-service`) — хранит статистику, рейтинг и историю матчей. Предоставляет эндпоинты `/v1/stats` и `/v1/matches`. Эндпоинт `/v1/profile` может быть реализован как агрегирующий эндпоинт в API Gateway, который объединяет данные из обоих сервисов (`person-service` и `stats-service`).
        
    - **Queue/Matchmaking Service** — обслуживает очередь игроков. При получении запроса `/v1/queue/join` добавляет пользователя в очередь (хранится в Redis Sorted Set). Если найдён соперник, создаётся сущность «Матч», и обоим игрокам отправляется событие `match_found` через WebSocket. Алгоритм может учитывать рейтинг игроков (ELO) и время ожидания для справедливого подбора.
        
    - **Game Service** — управляет ходом боя: принимает выборы игроков через REST (`/v1/game/move`) или WebSocket, вычисляет урон, обновляет состояние матча и рассылает события `turn_start`, `turn_update`, `turn_result` и `game_end`. Для масштабирования WebSocket‑соединений используются два подхода:
        
        1. **Брокер сообщений** — Spring Boot с модулем STOMP и внешним брокером (RabbitMQ/ActiveMQ). При горизонтальном масштабировании сервисы синхронизируют сообщения через брокер; это рекомендуется документацией Spring, чтобы избежать потери состояния[levelup.gitconnected.com](https://levelup.gitconnected.com/spring-boot-scaling-strategies-websockets-f7acf7ef45e5?gi=c3b6d4d02bec#:~:text=connection%20between%20the%20client%20and,connections%20unique%20to%20each%20node).
            
        2. **Внешний WebSocket‑сервис** — например, Azure Web PubSub или AWS API Gateway WebSocket. Клиент подключается к сервису, который масштабирует соединения; наши сервисы взаимодействуют с ним через HTTP‑вебхуки[levelup.gitconnected.com](https://levelup.gitconnected.com/spring-boot-scaling-strategies-websockets-f7acf7ef45e5?gi=c3b6d4d02bec#:~:text=connection%20between%20the%20client%20and,connections%20unique%20to%20each%20node). Такой подход разгружает приложения и упрощает масштабирование.
            
    - **Stats Service** — хранит историю матчей, список ходов, рассчитывает рейтинг, предоставляет API `/v1/matches` для получения списка матчей и `/v1/stats` для получения статистики пользователя. Поддерживает фильтрацию по периоду, пагинацию, экспорты и аналитику.
        
    
    Все сервисы публикуют OpenAPI‑спецификации, что упрощает генерацию клиентов и тестирование.
    
4. **Система сообщений (RabbitMQ/Kafka/Redis)**
    
    - Используется для очереди матчмейкинга и передачи событий между сервисами. Redis обеспечивает быструю структуру данных для очереди и блокировки. В текущей реализации используется Redis для очереди матчмейкинга. RabbitMQ или Kafka могут быть добавлены на следующем этапе для доставки сообщений между инстансами, что позволит масштабировать Game Service и Matchmaking Service.
        
5. **Базы данных**
    
    - **PostgreSQL** для транзакционных данных (пользователи, матчи, ходов). Для каждого сервиса выделена отдельная схема/база. Разделение данных между сервисами предотвращает взаимное влияние и поддерживает принцип DDD[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=,and%20defeats%20the%20purpose%20of). Возможны миграции с помощью Flyway или Liquibase.
        
    - **Redis** используется как кэш и хранилище сессий/очередей. Его можно разворачивать в кластере для обеспечения высокой доступности.
        
6. **Дополнительные компоненты**
    
    - **CI/CD**: использование GitHub Actions или Jenkins. Автоматическое тестирование (unit, интеграционные, e2e) с последующим деплоем в Kubernetes или Docker Swarm.
        
    - **Мониторинг и логирование**: интеграция с Prometheus/Grafana и ELK‑стеком. Для трассировки распределённых запросов — OpenTelemetry. Соблюдается централизованный сбор логов, метрик и алертов.
        
    - **Infrastructure**: контейнеризация (Docker), оркестрация (Kubernetes). Балансировщики нагрузки (Ingress Controller, Nginx) и autoscaling. Используется zero‑downtime deployment (rolling updates, blue‑green).
        

## Обоснование архитектурных решений и сравнение с практиками

### Домен‑ориентированное проектирование и микросервисы

Исходная спецификация предполагала монолитное приложение с несколькими REST‑эндпоинтами и WebSocket‑сервером. В промышленной разработке предпочтительно разделять систему на независимые сервисы по доменным границам. Методика **Domain‑Driven Design** (DDD) помогает определять _границы контекстов_ и избегать «распределённого монолита»: деление по техническим слоям приводит к зависимости между сервисами и сложности развертывания[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=1,for%20Service%20Boundaries). Каждый сервис владеет своей моделью данных и базой, что облегчает масштабирование и эволюцию.

### API Gateway и BFF

Чем больше сервисов, тем сложнее клиенту взаимодействовать напрямую. Паттерн **API Gateway** предоставляет единый вход, маршрутизирует запросы и реализует общие функции (аутентификация, rate limiting, логирование)[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=2). Он также позволяет объединять ответы нескольких сервисов в один, что важно для мобильных клиентов (паттерн Backend‑for‑Frontend).

### Безопасность

- **Транспорт**: весь трафик проходит через HTTPS/WSS. Gateway отклоняет небезопасные соединения.
    
- **Аутентификация и хранение паролей**: используется Keycloak как Identity Provider, который обеспечивает безопасное хранение паролей с использованием проверенных алгоритмов (PBKDF2, bcrypt, Argon2). Keycloak автоматически применяет соль для каждого пароля, что делает невозможным использование радужных таблиц. Такой подход соответствует рекомендациям OWASP и позволяет использовать готовые, проверенные решения вместо собственной реализации[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=third).
    
- **Проверка пароля на утечки**: при регистрации пароль проверяется на наличие в базе утечек (Have I Been Pwned)[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=third).
    
- **Разрешение вставки паролей**: веб‑форма должна разрешать копирование/вставку пароля, иначе пользователи используют простые, легко угадываемые пароли[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Allow%20password%20pasting).
    
- **Не требовать периодической смены паролей** — это не повышает безопасность, но раздражает пользователей и приводит к использованию слабых паролей[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=Don%27t%20force%20password%20updates).
    
- **Защита API**: rate limiting, CSRF‑token, проверка входных данных, защита от SQL‑/NoSQL‑инъекций и XSS. Используются механизмы фильтрации на уровне Gateway и в сервисах.
    

### Масштабирование и WebSocket

- **Долгоживущие соединения**. WebSocket обеспечивает двустороннюю связь с низкой задержкой, но его состояние усложняет масштабирование: соединения требуют постоянного серверного ресурса, а балансировка нагрузки — sticky‑sessions или синхронизация состояния[ably.com](https://ably.com/topic/websocket-architecture-best-practices#:~:text=Low%20overhead%20after%20initial%20handshake).
    
- **Синхронизация**. В Spring Boot для масштабирования WebSocket рекомендуется либо внешняя шина сообщений (RabbitMQ/ActiveMQ), либо перенос управления соединениями на сервис облачного провайдера[levelup.gitconnected.com](https://levelup.gitconnected.com/spring-boot-scaling-strategies-websockets-f7acf7ef45e5?gi=c3b6d4d02bec#:~:text=connection%20between%20the%20client%20and,connections%20unique%20to%20each%20node). Это позволяет разделить соединения между узлами и избежать потери сообщений.
    
- **Прокси WebSocket**. Использование Nginx/Envoy в качестве прокси позволит управлять TLS‑терминацией и равномерно распределять подключившихся клиентов, а sticky‑sessions обеспечат привязку пользователя к нужному экземпляру.
    

### Модель данных

- **User**: `id` (UUID), `email` (уникален), `nickname`, `createdAt`, `updatedAt`. Пароли и токены хранятся в Keycloak, а не в базе данных сервиса. Для связи с Keycloak используется `keycloakUserId` (опционально).
    
- **Match**: `id`, `player1Id`, `player2Id`, `status` (`waiting`/`in_progress`/`finished`), `player1HP`, `player2HP`, `currentTurnStart`, `turnNumber`, `createdAt`, `finishedAt`.
    
- **Move**: `id`, `matchId`, `playerId`, `turnNumber`, `attackTarget`, `defenseTarget`, `timestamp`.
    
- **Queue**: хранится в Redis как sorted set, элемент — пользователь с отметкой времени.
    
- **Stats**: агрегированные показатели (количество побед/поражений, средняя длительность боёв), таблица `matches` и индексы для быстрых выборок.
    

Каждый сервис может расширить модель: например, внедрить рейтинг ELO (таблица `ratings`) или магазин косметических предметов.

### API и события

|Метод|Сервис|Описание|
|---|---|---|
|`POST /v1/auth/registration`|Auth Service|Регистрация пользователя. Передаёт `email`, `password`, `nickname`. Возвращает `userId` и JWT. Проверяет пароль на утечки и силу.|
|`POST /v1/auth/login`|Auth Service|Вход. Принимает `email` и `password`, выдаёт JWT/refresh token.|
|`GET /v1/persons/{id}`|Person Service|Возвращает персональные данные пользователя: id, email, nickname.|
|`GET /v1/stats`|Stats Service|Возвращает статистику текущего пользователя: рейтинг, статистику побед/поражений.|
|`POST /v1/queue/join`|Matchmaking Service|Добавляет пользователя в очередь. Отвечает сообщением `waiting`.|
|`POST /v1/queue/leave`|Matchmaking Service|Удаляет пользователя из очереди.|
|`POST /v1/game/move`|Game Service|Принимает ход (`matchId`, `attackTarget`, `defenseTarget`, `turnNumber`). Возвращает подтверждение.|
|`GET /v1/matches`|Stats Service|Возвращает список прошлых матчей (дата, соперник, результат) с поддержкой фильтрации и пагинации.|

**WebSocket каналы**:

- `/ws/queue` — уведомления о найденном матче. Сервер отправляет `{type: "match_found", matchId, opponentNickname}`.
    
- `/ws/game/{matchId}` — игровая сессия. Сервер отправляет события:
    
    - `turn_start`: номер хода и время окончания.
        
    - `turn_update`: уведомление о получении хода одним из игроков.
        
    - `turn_result`: содержит выбранные зоны, нанесённый урон и текущий HP обоих игроков.
        
    - `game_end`: результат боя.
        

### Тестирование и качество

- **Unit‑тесты**: компоненты React тестируются с помощью Jest + React Testing Library. Бэкенд — JUnit 5 и Mockito.
    
- **Интеграционные тесты**: e2e‑сценарии с использованием Playwright или Cypress для фронт‑энда и Testcontainers для бэк‑энда.
    
- **Нагрузочное тестирование**: симуляция тысяч одновременных боёв для проверки WebSocket‑масштабируемости и реактивности API.
    
- **Security‑тесты**: использование OWASP ZAP и проверка соответствия OWASP Top 10.
    

### Расширение и эволюция

Исходная спецификация перечисляла возможные улучшения: рейтинговая система, чат, косметические предметы, мобильное приложение. Предложенная архитектура учитывает эти направления:

- **Рейтинг и уровни**: сервис Stats может рассчитывать ELO‑рейтинг и отправлять изменения в Person Service для обновления профиля пользователя.
    
- **Чат**: отдельный WebSocket‑канал `/ws/chat/{matchId}`. Фильтрация нежелательных слов выполняется с помощью модерации и ML‑сервисов.
    
- **Косметические предметы**: отдельный сервис (Shop Service) со своей базой данных и микроплатежами.
    
- **Мобильное приложение**: использует тот же API. Для лучшей производительности можно реализовать GraphQL слой или BFF.
    

### Соответствие нефункциональным требованиям

- **Производительность**: API отвечает за ~200 мс, WebSocket — задержка < 100 мс. Благодаря кэшированию и использованием message broker удаётся выдерживать пиковые нагрузки.
    
- **Надёжность**: система рассчитана на одновременное участие нескольких тысяч пользователей. Использование горизонтального масштабирования, отказоустойчивых брокеров и репликации БД обеспечивает высокую доступность.
    
- **Логирование и мониторинг**: важные события (регистрация, вход, начало/конец боя, ошибки) логируются централизованно. Метрики (задержки, число подключений, перегрузки) отображаются в Grafana.
    
- **Масштабируемость**: разделение на сервисы и использование брокеров позволяет масштабировать каждый компонент независимо, устранять «узкие места» и быстро разворачивать новые функции.
    

## Заключение

Приведённая архитектура объединяет требования аналитиков и лучшие производственные практики 2025 года.

- **React + Java (Spring Boot)** обеспечивает стабильную, хорошо поддерживаемую технологическую основу.
    
- **Разделение на микросервисы** с использованием **DDD**, **API Gateway** и собственных баз данных повышает гибкость и масштабируемость системы[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=1,for%20Service%20Boundaries)[kdpisda.in](https://kdpisda.in/top-9-microservices-architecture-best-practices-for-2025/#:~:text=2).
    
- **Безопасность** реализована согласно рекомендациям OWASP и Google: использование Keycloak для безопасного хранения паролей (PBKDF2/bcrypt/Argon2), проверка на утечки, разрешение вставки паролей, отсутствие принудительных смен, поддержка MFA через Keycloak[cheatsheetseries.owasp.org](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#:~:text=However%2C%20once%20an%20attacker%20has,as%20resource%20intensive%20as%20possible)[web.dev](https://web.dev/articles/sign-up-form-best-practices#:~:text=third).
    
- **Масштабирование WebSocket** решается через использование внешних брокеров/сервисов и прокси, что соответствует рекомендациям об архитектуре WebSocket[ably.com](https://ably.com/topic/websocket-architecture-best-practices#:~:text=Low%20overhead%20after%20initial%20handshake)[levelup.gitconnected.com](https://levelup.gitconnected.com/spring-boot-scaling-strategies-websockets-f7acf7ef45e5?gi=c3b6d4d02bec#:~:text=connection%20between%20the%20client%20and,connections%20unique%20to%20each%20node).
    

Такой подход позволяет создать честную, безопасную и масштабируемую игру, готовую к дальнейшему развитию и изменению бизнес‑требований.